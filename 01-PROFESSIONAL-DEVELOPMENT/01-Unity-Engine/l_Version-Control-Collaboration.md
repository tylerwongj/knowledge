# @l-Version-Control-Collaboration - Unity Team Development & Git Workflows

## ðŸŽ¯ Learning Objectives
- Master Git workflows specifically optimized for Unity projects
- Learn Unity-specific version control best practices and team collaboration
- Understand merge conflict resolution for Unity assets and scenes
- Apply AI/LLM tools to automate Git workflows and resolve complex conflicts

---

## ðŸ”§ Unity Project Git Configuration

### Essential Git Setup for Unity
Unity projects require specific Git configuration to handle binary assets and large files effectively:

**.gitignore for Unity Projects:**
```gitignore
# Unity generated files
[Ll]ibrary/
[Tt]emp/
[Oo]bj/
[Bb]uild/
[Bb]uilds/
[Ll]ogs/
[Uu]ser[Ss]ettings/

# MemoryCaptures can get excessive in size
/[Mm]emoryCaptures/

# Asset meta data should only be ignored when the corresponding asset is also ignored
!/[Aa]ssets/**/*.meta

# Uncomment this line if you wish to ignore the asset store tools plugin
# /[Aa]ssets/AssetStoreTools*

# Autogenerated Jetbrains Rider plugin
/[Aa]ssets/Plugins/Editor/JetBrains*

# Visual Studio cache directory
.vs/

# Gradle cache directory
.gradle/

# Autogenerated VS/MD/Consulo solution and project files
ExportedObj/
.consulo/
*.csproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd
*.pdb
*.mdb
*.opendb
*.VC.db

# Unity3D generated meta files
*.pidb.meta
*.pdb.meta
*.mdb.meta

# Unity3D generated file on crash reports
sysinfo.txt

# Builds
*.apk
*.aab
*.unitypackage
*.app

# Crashlytics generated file
crashlytics-build.properties

# Packed Addressables
/[Aa]ssets/[Aa]ddressable[Aa]ssets[Dd]ata/*/*.bin*

# Temporary auto-generated Android Assets
/[Aa]ssets/[Ss]treaming[Aa]ssets/aa.meta
/[Aa]ssets/[Ss]treaming[Aa]ssets/aa/*
```

**Git LFS Configuration:**
```bash
# Install Git LFS
git lfs install

# Track Unity binary files
git lfs track "*.psd"
git lfs track "*.fbx"
git lfs track "*.png"
git lfs track "*.jpg"
git lfs track "*.jpeg"
git lfs track "*.mp3"
git lfs track "*.wav"
git lfs track "*.ogg"
git lfs track "*.mp4"
git lfs track "*.mov"
git lfs track "*.unity"
git lfs track "*.asset"
git lfs track "*.prefab"
git lfs track "*.mat"
git lfs track "*.anim"
git lfs track "*.controller"

# Commit the .gitattributes file
git add .gitattributes
git commit -m "Configure Git LFS for Unity assets"
```

### Unity Editor Version Control Settings
Configure Unity to work seamlessly with Git:

```csharp
// Editor script to set up version control preferences
[InitializeOnLoad]
public class UnityVersionControlSetup
{
    static UnityVersionControlSetup()
    {
        // Force text serialization for better Git compatibility
        EditorSettings.serializationMode = SerializationMode.ForceText;
        
        // Use visible meta files
        EditorSettings.externalVersionControlSupport = "Visible Meta Files";
        
        // Set line endings to Unix for cross-platform compatibility
        EditorSettings.lineEndingsForNewScripts = LineEndingsMode.Unix;
        
        // Cache server settings for better performance
        EditorSettings.spritePackerCacheMaxMemoryUsage = 1024;
        
        Debug.Log("Unity version control settings configured for Git");
    }
}
```

---

## ðŸš€ Git Workflow Strategies for Unity Teams

### Feature Branch Workflow
Standard workflow adapted for Unity development:

```bash
# Create and switch to a new feature branch
git checkout -b feature/player-combat-system

# Work on your feature, making atomic commits
git add Assets/Scripts/Combat/
git commit -m "Add basic combat system with health and damage

- Implement Health component with max health and current health
- Add DamageDealer interface for weapons and projectiles
- Create CombatManager for handling damage calculations
- Include unit tests for combat logic"

# Keep feature branch updated with main
git fetch origin
git rebase origin/main

# Push feature branch
git push -u origin feature/player-combat-system

# Create pull request for code review
```

### Unity-Specific Branching Strategy
```bash
# Main branches
main          # Production-ready code
develop       # Integration branch for features
release/v1.2  # Release preparation branch

# Feature branches
feature/inventory-system
feature/multiplayer-networking
feature/ui-redesign

# Hotfix branches
hotfix/critical-save-bug
hotfix/performance-optimization

# Asset branches (for large asset updates)
assets/character-models
assets/environment-art
assets/audio-overhaul
```

### Merge Conflict Resolution for Unity

**Scene Merge Conflicts:**
```bash
# Unity YAML merge tool setup in .gitconfig
[merge]
    tool = unityyamlmerge

[mergetool "unityyamlmerge"]
    trustExitCode = false
    cmd = 'C:\\Program Files\\Unity\\Hub\\Editor\\2022.3.15f1\\Editor\\Data\\Tools\\UnityYAMLMerge.exe' merge -p "$BASE" "$REMOTE" "$LOCAL" "$MERGED"
```

**Manual Conflict Resolution Workflow:**
```csharp
// Custom editor tool for conflict resolution
public class ConflictResolver : EditorWindow
{
    [MenuItem("Tools/Git/Resolve Scene Conflicts")]
    public static void ShowWindow()
    {
        GetWindow<ConflictResolver>("Conflict Resolver");
    }
    
    void OnGUI()
    {
        GUILayout.Label("Unity Scene Conflict Resolution", EditorStyles.boldLabel);
        
        if (GUILayout.Button("Backup Current Scene"))
        {
            BackupCurrentScene();
        }
        
        if (GUILayout.Button("Analyze Conflicts"))
        {
            AnalyzeSceneConflicts();
        }
        
        if (GUILayout.Button("Apply Remote Changes"))
        {
            ApplyRemoteChanges();
        }
        
        if (GUILayout.Button("Keep Local Changes"))
        {
            KeepLocalChanges();
        }
    }
    
    private void BackupCurrentScene()
    {
        var scenePath = EditorSceneManager.GetActiveScene().path;
        var backupPath = scenePath.Replace(".unity", $"_backup_{System.DateTime.Now:yyyyMMdd_HHmmss}.unity");
        
        AssetDatabase.CopyAsset(scenePath, backupPath);
        Debug.Log($"Scene backed up to: {backupPath}");
    }
    
    private void AnalyzeSceneConflicts()
    {
        // Parse Git conflict markers in scene files
        var conflicts = GitConflictParser.ParseUnitySceneConflicts();
        
        foreach (var conflict in conflicts)
        {
            Debug.Log($"Conflict in {conflict.ObjectName}: {conflict.Property}");
        }
    }
}
```

---

## ðŸŽ® Team Collaboration Best Practices

### Asset Locking and Communication
Prevent conflicts on binary assets through team coordination:

```csharp
// Asset lock notification system
[InitializeOnLoad]
public class AssetLockManager
{
    private static readonly string LOCK_FILE_PATH = "Temp/AssetLocks.json";
    private static Dictionary<string, AssetLock> assetLocks = new Dictionary<string, AssetLock>();
    
    static AssetLockManager()
    {
        LoadAssetLocks();
        EditorApplication.projectWindowItemOnGUI += OnProjectWindowItemGUI;
    }
    
    [MenuItem("Assets/Lock for Editing", priority = 20)]
    public static void LockSelectedAsset()
    {
        var selectedPath = AssetDatabase.GetAssetPath(Selection.activeObject);
        if (string.IsNullOrEmpty(selectedPath)) return;
        
        var lockInfo = new AssetLock
        {
            AssetPath = selectedPath,
            LockedBy = System.Environment.UserName,
            LockTime = System.DateTime.Now,
            ComputerName = System.Environment.MachineName
        };
        
        assetLocks[selectedPath] = lockInfo;
        SaveAssetLocks();
        
        // Notify team via Slack/Discord webhook
        NotifyTeamOfLock(lockInfo);
        
        Debug.Log($"Asset locked: {selectedPath} by {lockInfo.LockedBy}");
    }
    
    private static void OnProjectWindowItemGUI(string guid, Rect selectionRect)
    {
        var assetPath = AssetDatabase.GUIDToAssetPath(guid);
        
        if (assetLocks.ContainsKey(assetPath))
        {
            var lockIcon = EditorGUIUtility.IconContent("d_InspectorLock");
            var iconRect = new Rect(selectionRect.xMax - 16, selectionRect.y, 16, 16);
            GUI.Label(iconRect, lockIcon);
        }
    }
    
    private static void NotifyTeamOfLock(AssetLock lockInfo)
    {
        var webhookUrl = EditorPrefs.GetString("TeamWebhookURL", "");
        if (string.IsNullOrEmpty(webhookUrl)) return;
        
        var message = new
        {
            text = $"ðŸ”’ Asset locked by {lockInfo.LockedBy}: `{lockInfo.AssetPath}`",
            username = "Unity Asset Manager"
        };
        
        // Send webhook notification (implementation depends on your chat platform)
        SendWebhookNotification(webhookUrl, message);
    }
}

[System.Serializable]
public class AssetLock
{
    public string AssetPath;
    public string LockedBy;
    public System.DateTime LockTime;
    public string ComputerName;
    public string Reason;
}
```

### Branch Protection and Code Review
Automated quality gates for Unity projects:

```yaml
# GitHub branch protection rules
name: Unity Quality Gate
on:
  pull_request:
    branches: [main, develop]

jobs:
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Unity License
        uses: game-ci/unity-activate@v2
        with:
          unity-license: ${{ secrets.UNITY_LICENSE }}
      
      - name: Run Tests
        uses: game-ci/unity-test-runner@v2
        with:
          testMode: all
          coverageOptions: 'generateAdditionalMetrics;generateHtmlReport'
      
      - name: Build Project
        uses: game-ci/unity-builder@v2
        with:
          targetPlatform: StandaloneWindows64
          
      - name: Check Asset Validity
        run: |
          # Custom script to validate asset references
          python scripts/validate_assets.py
          
      - name: Performance Regression Test
        run: |
          # Run performance benchmarks
          python scripts/performance_tests.py
          
      - name: Comment PR with Results
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const testResults = fs.readFileSync('test-results.xml', 'utf8');
            const comment = `## Test Results\n\`\`\`\n${testResults}\n\`\`\``;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

### Team Workflow Documentation
Clear processes for team members:

```markdown
# Unity Team Development Guidelines

## Daily Workflow
1. **Start of Day**: Pull latest changes from develop branch
2. **Before Coding**: Check asset locks and team announcements
3. **During Development**: Make atomic commits with clear messages
4. **End of Day**: Push feature branch and update team on progress

## Asset Management Rules
- Lock binary assets before editing (scenes, prefabs, materials)
- Use descriptive commit messages for asset changes
- Include screenshots for visual changes in pull requests
- Test asset references after merging

## Code Review Checklist
- [ ] All tests pass locally
- [ ] No console errors or warnings
- [ ] Performance impact assessed
- [ ] Documentation updated if needed
- [ ] Asset references intact
- [ ] Code follows team style guide

## Merge Conflict Resolution
1. Use Unity YAML merge tool for scene/prefab conflicts
2. Test resolved conflicts in play mode
3. Ask for help if unsure about resolution
4. Document complex conflict resolutions
```

---

## ðŸ¤– AI/LLM Integration for Version Control

### Automated Commit Message Generation
AI-powered commit message creation based on code changes:

```csharp
public class AICommitMessageGenerator
{
    public async Task<string> GenerateCommitMessage(List<string> changedFiles)
    {
        var prompt = $@"
        Generate a clear, concise Git commit message for Unity project changes:
        
        Changed files:
        {string.Join('\n', changedFiles)}
        
        Follow conventional commit format:
        - feat: for new features
        - fix: for bug fixes
        - refactor: for code restructuring
        - docs: for documentation
        - test: for testing
        - style: for formatting changes
        
        Include brief description and bullet points for major changes.
        Maximum 72 characters for first line.
        ";
        
        var response = await aiService.GenerateText(prompt);
        return response.Trim();
    }
}

// Usage in custom Git integration
[MenuItem("Git/Generate Commit Message")]
public static async void GenerateSmartCommitMessage()
{
    var changedFiles = GetChangedFiles();
    var generator = new AICommitMessageGenerator();
    var message = await generator.GenerateCommitMessage(changedFiles);
    
    EditorGUIUtility.systemCopyBuffer = message;
    Debug.Log($"Generated commit message (copied to clipboard):\n{message}");
}
```

### Intelligent Merge Conflict Resolution
AI-assisted conflict analysis and resolution suggestions:

```csharp
public class AIConflictResolver
{
    public async Task<ConflictResolution> AnalyzeConflict(string conflictContent)
    {
        var prompt = $@"
        Analyze this Unity Git merge conflict and provide resolution suggestions:
        
        Conflict Content:
        {conflictContent}
        
        Provide:
        1. Type of conflict (scene, prefab, script, settings)
        2. Likely cause of conflict
        3. Recommended resolution approach
        4. Potential risks of each resolution option
        5. Post-resolution testing suggestions
        
        Respond in JSON format.
        ";
        
        var response = await aiService.Analyze(prompt);
        return JsonUtility.FromJson<ConflictResolution>(response);
    }
    
    public async Task<string> SuggestManualResolution(SceneConflict conflict)
    {
        var prompt = $@"
        Suggest step-by-step manual resolution for Unity scene conflict:
        
        Conflict Details:
        - Object: {conflict.ObjectName}
        - Property: {conflict.PropertyName}
        - Local Value: {conflict.LocalValue}
        - Remote Value: {conflict.RemoteValue}
        
        Provide detailed Unity Editor steps to resolve this conflict safely.
        ";
        
        return await aiService.GenerateText(prompt);
    }
}
```

### Code Review Automation
AI-powered code review and feedback generation:

```csharp
public class AICodeReviewer
{
    public async Task<CodeReviewResult> ReviewPullRequest(PullRequestData prData)
    {
        var prompt = $@"
        Review this Unity pull request for code quality and best practices:
        
        Title: {prData.Title}
        Description: {prData.Description}
        
        Changed Files:
        {string.Join('\n', prData.ChangedFiles.Select(f => $"- {f.Path} (+{f.Additions} -{f.Deletions})"))}
        
        Code Diff:
        {prData.Diff}
        
        Focus on:
        - Unity best practices
        - Performance implications
        - Code maintainability
        - Potential bugs or issues
        - Testing coverage
        
        Provide constructive feedback with specific suggestions.
        ";
        
        var response = await aiService.ReviewCode(prompt);
        return ParseCodeReviewResponse(response);
    }
}
```

---

## ðŸ’¡ Professional Development Integration

### Git Hooks for Unity Projects
Automated quality checks and workflows:

```bash
#!/bin/sh
# pre-commit hook for Unity projects

echo "Running Unity pre-commit checks..."

# Check for Unity Editor running
if pgrep -x "Unity" > /dev/null; then
    echo "Warning: Unity Editor is running. Consider closing it before committing."
fi

# Validate scene references
python scripts/validate_scene_references.py
if [ $? -ne 0 ]; then
    echo "Scene reference validation failed!"
    exit 1
fi

# Check for missing meta files
missing_meta=$(git diff --cached --name-only --diff-filter=A | grep -v '\.meta$' | while read file; do
    if [ -f "$file" ] && [ ! -f "$file.meta" ]; then
        echo "$file"
    fi
done)

if [ ! -z "$missing_meta" ]; then
    echo "Missing .meta files for:"
    echo "$missing_meta"
    echo "Please generate meta files and add them to the commit."
    exit 1
fi

# Run Unity tests
echo "Running Unity tests..."
/Applications/Unity/Hub/Editor/2022.3.15f1/Unity.app/Contents/MacOS/Unity \
    -batchmode \
    -quit \
    -projectPath $(pwd) \
    -runTests \
    -testPlatform EditMode \
    -testResults test-results.xml

if [ $? -ne 0 ]; then
    echo "Unity tests failed!"
    exit 1
fi

echo "Pre-commit checks passed!"
```

### Team Onboarding Automation
Scripted setup for new team members:

```bash
#!/bin/bash
# setup-unity-project.sh - New team member onboarding script

echo "Setting up Unity project for development..."

# Clone repository with LFS
git lfs install
git clone https://github.com/yourteam/your-unity-project.git
cd your-unity-project

# Set up Git configuration
git config core.autocrlf false
git config merge.tool unityyamlmerge

# Install Unity version from ProjectVersion.txt
UNITY_VERSION=$(grep "m_EditorVersion:" ProjectSettings/ProjectVersion.txt | cut -d' ' -f2)
echo "Required Unity version: $UNITY_VERSION"

# Set up Git hooks
cp scripts/git-hooks/* .git/hooks/
chmod +x .git/hooks/*

# Install project dependencies
echo "Installing Node.js dependencies for build tools..."
npm install

# Set up environment variables
cp .env.example .env
echo "Please update .env file with your local settings"

# Initialize Unity project
echo "Opening Unity to initialize project..."
/Applications/Unity/Hub/Editor/$UNITY_VERSION/Unity.app/Contents/MacOS/Unity \
    -batchmode \
    -quit \
    -projectPath $(pwd) \
    -importPackage

echo "Setup complete! Please review the README.md for additional setup steps."
```

---

## ðŸŽ¯ Interview Preparation & Key Takeaways

### Common Version Control Interview Questions

**"How do you handle Unity project version control in a team?"**
- Git with LFS for binary assets and proper .gitignore configuration
- Feature branch workflow with code review processes
- Asset locking strategies for binary files (scenes, prefabs)
- Merge conflict resolution techniques for Unity-specific files

**"Describe your approach to code reviews in Unity projects"**
- Automated testing and build validation in CI/CD pipelines
- Manual review focusing on Unity best practices and performance
- Asset validation and reference integrity checking
- Documentation and knowledge sharing through review comments

**"How do you prevent merge conflicts in Unity development?"**
- Clear team communication about asset editing and locking
- Feature branch strategy with regular rebasing
- Scene and prefab decomposition for parallel development
- Consistent Unity Editor settings across team members

### Essential Version Control Skills

**Technical Proficiency:**
- Git expertise with Unity-specific configuration and workflows
- Understanding of Git LFS for binary asset management
- Proficiency with Unity's YAML merge tools and conflict resolution
- Experience with branching strategies and release management

**Professional Workflow:**
- Code review processes and quality gate implementation
- Continuous integration setup for Unity projects
- Team collaboration tools and communication protocols
- Documentation of version control procedures and best practices

**Industry Best Practices:**
- Automated testing and validation in version control workflows
- Asset management strategies for large Unity projects
- Performance monitoring and regression detection
- Knowledge sharing and mentoring on version control best practices