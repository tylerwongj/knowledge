# @p-Git-Workflows-Unity-Team-Development

## ðŸŽ¯ Learning Objectives

- Master advanced Git workflows optimized for Unity team development
- Implement Git LFS strategies for large Unity assets
- Create automated Unity-specific Git hooks and workflows
- Build CI/CD pipelines for Unity projects with version control integration

## ðŸ”§ Unity Git Configuration

### Essential .gitignore and .gitattributes

```bash
# Unity .gitignore (Comprehensive)
# This file is to be used with Unity version 2019.4 and later

# Unity generated files
[Ll]ibrary/
[Tt]emp/
[Oo]bj/
[Bb]uild/
[Bb]uilds/
[Ll]ogs/
[Uu]ser[Ss]ettings/

# Memory Dumps
MemoryCaptures/

# Asset meta data (should be visible in project)
*.tmp
*.swp

# Unity3D generated files
*.pidb
*.booproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd
*.pdb
*.mdb
*.opendb
*.VC.db

# Unity3D generated meta files
*.pidb.meta
*.pdb.meta
*.mdb.meta

# Unity3D assembly definition files
*.asmdef.meta

# Autogenerated Jetbrains Rider plugin
[Aa]ssets/Plugins/Editor/JetBrains*

# Visual Studio cache directory
.vs/

# Gradle cache directory (Android)
.gradle/

# Autogenerated Android files
[Aa]ssets/[Ss]treamingAssets/aa.meta
[Aa]ssets/[Ss]treamingAssets/aa/

# Crashlytics generated file
crashlytics-build.properties

# Packed Addressables
[Aa]ssets/[Aa]ddressable[Aa]ssets[Dd]ata/*/*.bin*

# Temporary auto-generated Android Assets
[Aa]ssets/[Ss]treamingAssets/aa/*

# Mac DS_Store files
.DS_Store

# Windows Thumbnail files
Thumbs.db

# Unity Cloud Build
/cloudbuild/

# Fmod cache
fmod_editor.log

# Wwise cache
.cache/
GeneratedSoundBanks/
Wwise_IDs.h

# WebGL builds
[Ww]eb[Gg][Ll]/

# Custom directories
[Dd]ocumentation~/
[Tt]ools~/

# IDE files
*.code-workspace
.vscode/
.idea/

# Package manager cache
[Pp]ackages/packages-lock.json

# Plastic SCM files
.plastic/

# Unity Collaborate files
.collabignore
.collab/
```

```bash
# Unity .gitattributes (Git LFS Configuration)
# 3D models
*.3ds filter=lfs diff=lfs merge=lfs -text
*.3dm filter=lfs diff=lfs merge=lfs -text
*.3dmf filter=lfs diff=lfs merge=lfs -text
*.blend filter=lfs diff=lfs merge=lfs -text
*.c4d filter=lfs diff=lfs merge=lfs -text
*.collada filter=lfs diff=lfs merge=lfs -text
*.dae filter=lfs diff=lfs merge=lfs -text
*.dxf filter=lfs diff=lfs merge=lfs -text
*.fbx filter=lfs diff=lfs merge=lfs -text
*.jas filter=lfs diff=lfs merge=lfs -text
*.lws filter=lfs diff=lfs merge=lfs -text
*.lxo filter=lfs diff=lfs merge=lfs -text
*.ma filter=lfs diff=lfs merge=lfs -text
*.max filter=lfs diff=lfs merge=lfs -text
*.mb filter=lfs diff=lfs merge=lfs -text
*.obj filter=lfs diff=lfs merge=lfs -text
*.ply filter=lfs diff=lfs merge=lfs -text
*.skp filter=lfs diff=lfs merge=lfs -text
*.stl filter=lfs diff=lfs merge=lfs -text
*.ztl filter=lfs diff=lfs merge=lfs -text

# Audio
*.aif filter=lfs diff=lfs merge=lfs -text
*.aiff filter=lfs diff=lfs merge=lfs -text
*.it filter=lfs diff=lfs merge=lfs -text
*.mod filter=lfs diff=lfs merge=lfs -text
*.mp3 filter=lfs diff=lfs merge=lfs -text
*.ogg filter=lfs diff=lfs merge=lfs -text
*.s3m filter=lfs diff=lfs merge=lfs -text
*.wav filter=lfs diff=lfs merge=lfs -text
*.xm filter=lfs diff=lfs merge=lfs -text

# Video
*.asf filter=lfs diff=lfs merge=lfs -text
*.avi filter=lfs diff=lfs merge=lfs -text
*.flv filter=lfs diff=lfs merge=lfs -text
*.mkv filter=lfs diff=lfs merge=lfs -text
*.mov filter=lfs diff=lfs merge=lfs -text
*.mp4 filter=lfs diff=lfs merge=lfs -text
*.mpeg filter=lfs diff=lfs merge=lfs -text
*.mpg filter=lfs diff=lfs merge=lfs -text
*.ogv filter=lfs diff=lfs merge=lfs -text
*.wmv filter=lfs diff=lfs merge=lfs -text

# Images
*.bmp filter=lfs diff=lfs merge=lfs -text
*.exr filter=lfs diff=lfs merge=lfs -text
*.gif filter=lfs diff=lfs merge=lfs -text
*.hdr filter=lfs diff=lfs merge=lfs -text
*.iff filter=lfs diff=lfs merge=lfs -text
*.jpeg filter=lfs diff=lfs merge=lfs -text
*.jpg filter=lfs diff=lfs merge=lfs -text
*.pict filter=lfs diff=lfs merge=lfs -text
*.png filter=lfs diff=lfs merge=lfs -text
*.psd filter=lfs diff=lfs merge=lfs -text
*.tga filter=lfs diff=lfs merge=lfs -text
*.tif filter=lfs diff=lfs merge=lfs -text
*.tiff filter=lfs diff=lfs merge=lfs -text
*.xcf filter=lfs diff=lfs merge=lfs -text

# Compressed Archive
*.7z filter=lfs diff=lfs merge=lfs -text
*.bz2 filter=lfs diff=lfs merge=lfs -text
*.gz filter=lfs diff=lfs merge=lfs -text
*.lzma filter=lfs diff=lfs merge=lfs -text
*.pbxuser filter=lfs diff=lfs merge=lfs -text
*.rar filter=lfs diff=lfs merge=lfs -text
*.tar filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text

# Compiled Dynamic Library
*.dll filter=lfs diff=lfs merge=lfs -text
*.pdb filter=lfs diff=lfs merge=lfs -text
*.so filter=lfs diff=lfs merge=lfs -text

# Fonts
*.otf filter=lfs diff=lfs merge=lfs -text
*.ttf filter=lfs diff=lfs merge=lfs -text

# Unity specific
*.cubemap filter=lfs diff=lfs merge=lfs -text
*.unitypackage filter=lfs diff=lfs merge=lfs -text

# Autodesk Fbx files
*.fbx filter=lfs diff=lfs merge=lfs -text

# Adobe files
*.ai filter=lfs diff=lfs merge=lfs -text
*.psb filter=lfs diff=lfs merge=lfs -text
*.psd filter=lfs diff=lfs merge=lfs -text

# Images
*.jpg filter=lfs diff=lfs merge=lfs -text
*.jpeg filter=lfs diff=lfs merge=lfs -text
*.png filter=lfs diff=lfs merge=lfs -text
*.apng filter=lfs diff=lfs merge=lfs -text
*.atsc filter=lfs diff=lfs merge=lfs -text
*.gif filter=lfs diff=lfs merge=lfs -text
*.bmp filter=lfs diff=lfs merge=lfs -text
*.exr filter=lfs diff=lfs merge=lfs -text
*.tga filter=lfs diff=lfs merge=lfs -text
*.tiff filter=lfs diff=lfs merge=lfs -text
*.tif filter=lfs diff=lfs merge=lfs -text
*.iff filter=lfs diff=lfs merge=lfs -text

# Unity YAML and meta files should use text-based merging
*.meta merge=unityyamlmerge diff
*.unity merge=unityyamlmerge diff
*.prefab merge=unityyamlmerge diff
*.asset merge=unityyamlmerge diff
*.mat merge=unityyamlmerge diff
*.anim merge=unityyamlmerge diff
*.controller merge=unityyamlmerge diff
*.overrideController merge=unityyamlmerge diff
*.mask merge=unityyamlmerge diff
*.renderTexture merge=unityyamlmerge diff
*.physicMaterial merge=unityyamlmerge diff
*.physicsMaterial2D merge=unityyamlmerge diff
*.lighting merge=unityyamlmerge diff
*.giparams merge=unityyamlmerge diff
*.mixer merge=unityyamlmerge diff
*.shadervariants merge=unityyamlmerge diff
*.preset merge=unityyamlmerge diff
*.asmdef merge=unityyamlmerge diff
*.asmref merge=unityyamlmerge diff

# Set line endings to LF for consistency
*.cs text eol=lf
*.js text eol=lf
*.boo text eol=lf
*.shader text eol=lf
*.hlsl text eol=lf
*.compute text eol=lf
*.cginc text eol=lf
*.glslinc text eol=lf
*.md text eol=lf
*.txt text eol=lf
*.json text eol=lf
*.xml text eol=lf
*.yml text eol=lf
*.yaml text eol=lf
```

### Unity Git Hooks

```bash
#!/bin/bash
# pre-commit hook for Unity projects
# Place this in .git/hooks/pre-commit and make executable with chmod +x

echo "Running Unity pre-commit checks..."

# Check if Unity is currently running (could cause conflicts)
if pgrep -x "Unity" > /dev/null; then
    echo "Warning: Unity Editor is currently running."
    echo "Consider closing Unity Editor to avoid potential conflicts."
    read -p "Continue anyway? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# Check for large files that should be in LFS
large_files=$(git diff --cached --name-only --diff-filter=A | xargs -I {} sh -c 'if [ -f "{}" ] && [ $(stat -f%z "{}" 2>/dev/null || stat -c%s "{}" 2>/dev/null || echo 0) -gt 104857600 ]; then echo "{}"; fi')

if [ ! -z "$large_files" ]; then
    echo "Error: Large files detected that should use Git LFS:"
    echo "$large_files"
    echo ""
    echo "Please add these files to Git LFS:"
    echo "git lfs track \"path/to/large/file\""
    echo "git add .gitattributes"
    exit 1
fi

# Check for missing .meta files
missing_meta_files=""
for file in $(git diff --cached --name-only --diff-filter=A); do
    if [[ -f "$file" && "$file" == Assets/* && ! "$file" == *.meta ]]; then
        meta_file="$file.meta"
        if [[ ! -f "$meta_file" ]]; then
            missing_meta_files="$missing_meta_files\n$meta_file"
        fi
    fi
done

if [ ! -z "$missing_meta_files" ]; then
    echo "Error: Missing .meta files detected:"
    echo -e "$missing_meta_files"
    echo ""
    echo "Unity generates .meta files automatically."
    echo "Please open Unity Editor to generate missing .meta files."
    exit 1
fi

# Check for orphaned .meta files
orphaned_meta_files=""
for file in $(git diff --cached --name-only --diff-filter=A | grep "\.meta$"); do
    original_file="${file%.*}"
    if [[ ! -f "$original_file" ]]; then
        orphaned_meta_files="$orphaned_meta_files\n$file"
    fi
done

if [ ! -z "$orphaned_meta_files" ]; then
    echo "Error: Orphaned .meta files detected:"
    echo -e "$orphaned_meta_files"
    echo ""
    echo "These .meta files have no corresponding asset."
    echo "Please remove them or add the missing assets."
    exit 1
fi

# Check for Unity-specific file integrity
echo "Checking Unity file integrity..."

# Check for binary files that should be text
binary_scene_files=$(git diff --cached --name-only --diff-filter=AM | grep "\.unity$" | xargs file | grep "binary" | cut -d: -f1)
if [ ! -z "$binary_scene_files" ]; then
    echo "Warning: Binary Unity scene files detected:"
    echo "$binary_scene_files"
    echo ""
    echo "Consider setting Unity to 'Force Text' serialization mode:"
    echo "Edit > Project Settings > Editor > Asset Serialization > Mode: Force Text"
fi

# Validate JSON files
for file in $(git diff --cached --name-only --diff-filter=AM | grep "\.json$"); do
    if [ -f "$file" ]; then
        if ! python3 -m json.tool "$file" > /dev/null 2>&1; then
            echo "Error: Invalid JSON file: $file"
            exit 1
        fi
    fi
done

# Check for accidentally committed temporary Unity files
temp_files=$(git diff --cached --name-only | grep -E "\.(tmp|temp)$|~$|\.orig$")
if [ ! -z "$temp_files" ]; then
    echo "Error: Temporary files detected in commit:"
    echo "$temp_files"
    echo ""
    echo "Please remove temporary files before committing."
    exit 1
fi

# Check for common Unity mistakes
echo "Checking for common Unity mistakes..."

# Check for hardcoded paths in scripts
hardcoded_paths=$(git diff --cached --name-only --diff-filter=AM | grep "\.cs$" | xargs grep -l "C:\\|/Users/\|/home/\|D:\\|E:\\" 2>/dev/null || true)
if [ ! -z "$hardcoded_paths" ]; then
    echo "Warning: Hardcoded file paths detected in:"
    echo "$hardcoded_paths"
    echo ""
    echo "Consider using relative paths or Unity's Application paths."
fi

# Check for Debug.Log statements in production code
debug_logs=$(git diff --cached --name-only --diff-filter=AM | grep "\.cs$" | xargs grep -l "Debug\.Log\|print(" 2>/dev/null || true)
if [ ! -z "$debug_logs" ]; then
    echo "Warning: Debug statements found in:"
    echo "$debug_logs"
    echo ""
    echo "Consider removing debug statements before production builds."
fi

echo "Unity pre-commit checks completed successfully!"
exit 0
```

```bash
#!/bin/bash
# post-merge hook for Unity projects
# Place this in .git/hooks/post-merge and make executable with chmod +x

echo "Running Unity post-merge tasks..."

# Check if Library folder needs to be rebuilt
if git diff HEAD@{1} HEAD --name-only | grep -q "ProjectSettings\|Packages/manifest.json"; then
    echo "Project settings or packages changed."
    echo "Consider reimporting assets or restarting Unity Editor."
    
    # Optionally delete Library to force fresh import
    read -p "Delete Library folder to force fresh import? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        if [ -d "Library" ]; then
            echo "Deleting Library folder..."
            rm -rf Library
            echo "Library folder deleted. Unity will rebuild on next launch."
        fi
    fi
fi

# Check for new LFS files that need to be pulled
new_lfs_files=$(git diff HEAD@{1} HEAD --name-only | xargs git check-attr filter | grep "filter: lfs" | cut -d: -f1)
if [ ! -z "$new_lfs_files" ]; then
    echo "New LFS files detected:"
    echo "$new_lfs_files"
    echo ""
    echo "Running git lfs pull to download new assets..."
    git lfs pull
fi

# Check for package changes
if git diff HEAD@{1} HEAD --name-only | grep -q "Packages/manifest.json"; then
    echo "Package manifest changed."
    echo "Unity will resolve package dependencies on next launch."
fi

echo "Post-merge tasks completed!"
```

## ðŸŽ® Unity Team Workflow Strategies

### GitFlow for Unity Development

```bash
#!/bin/bash
# Unity GitFlow helper script

set -e

MAIN_BRANCH="main"
DEVELOP_BRANCH="develop"
FEATURE_PREFIX="feature/"
RELEASE_PREFIX="release/"
HOTFIX_PREFIX="hotfix/"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Unity-specific pre-flight checks
unity_preflight_check() {
    log_info "Running Unity pre-flight checks..."
    
    # Check if Unity is running
    if pgrep -x "Unity" > /dev/null; then
        log_warn "Unity Editor is currently running."
        log_warn "Consider closing Unity to avoid conflicts."
    fi
    
    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD --; then
        log_error "You have uncommitted changes. Please commit or stash them first."
        exit 1
    fi
    
    # Check LFS status
    if git lfs status | grep -q "Objects to be pushed"; then
        log_warn "You have LFS objects that haven't been pushed."
        log_warn "Run 'git lfs push origin <branch>' after pushing your branch."
    fi
    
    log_info "Pre-flight checks completed."
}

# Start a new feature branch
start_feature() {
    local feature_name=$1
    
    if [ -z "$feature_name" ]; then
        log_error "Feature name is required."
        echo "Usage: $0 start-feature <feature-name>"
        exit 1
    fi
    
    unity_preflight_check
    
    local branch_name="${FEATURE_PREFIX}${feature_name}"
    
    log_info "Starting feature: $feature_name"
    log_info "Creating branch: $branch_name from $DEVELOP_BRANCH"
    
    git checkout $DEVELOP_BRANCH
    git pull origin $DEVELOP_BRANCH
    git checkout -b $branch_name
    
    log_info "Feature branch '$branch_name' created successfully!"
    log_info "Remember to:"
    log_info "1. Keep your branch up to date with develop"
    log_info "2. Test your changes thoroughly"
    log_info "3. Update documentation if needed"
}

# Finish a feature branch
finish_feature() {
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    if [[ ! "$current_branch" =~ ^${FEATURE_PREFIX} ]]; then
        log_error "Not on a feature branch. Current branch: $current_branch"
        exit 1
    fi
    
    unity_preflight_check
    
    local feature_name=${current_branch#$FEATURE_PREFIX}
    
    log_info "Finishing feature: $feature_name"
    
    # Update develop branch
    git checkout $DEVELOP_BRANCH
    git pull origin $DEVELOP_BRANCH
    
    # Merge feature branch
    log_info "Merging $current_branch into $DEVELOP_BRANCH"
    git merge --no-ff $current_branch -m "Merge feature '$feature_name'"
    
    # Push changes
    git push origin $DEVELOP_BRANCH
    
    # Clean up feature branch
    log_info "Cleaning up feature branch"
    git branch -d $current_branch
    git push origin --delete $current_branch 2>/dev/null || true
    
    log_info "Feature '$feature_name' finished successfully!"
}

# Start a release branch
start_release() {
    local version=$1
    
    if [ -z "$version" ]; then
        log_error "Version is required."
        echo "Usage: $0 start-release <version>"
        exit 1
    fi
    
    unity_preflight_check
    
    local branch_name="${RELEASE_PREFIX}${version}"
    
    log_info "Starting release: $version"
    
    git checkout $DEVELOP_BRANCH
    git pull origin $DEVELOP_BRANCH
    git checkout -b $branch_name
    
    # Update Unity project version (if ProjectSettings.asset exists)
    if [ -f "ProjectSettings/ProjectSettings.asset" ]; then
        log_info "Updating Unity project version to $version"
        
        # Backup original file
        cp "ProjectSettings/ProjectSettings.asset" "ProjectSettings/ProjectSettings.asset.backup"
        
        # Update version (this is a simplified approach)
        sed -i.bak "s/bundleVersion: .*/bundleVersion: $version/" "ProjectSettings/ProjectSettings.asset"
        
        git add "ProjectSettings/ProjectSettings.asset"
        git commit -m "Bump version to $version"
    fi
    
    log_info "Release branch '$branch_name' created successfully!"
    log_info "Remember to:"
    log_info "1. Test the release thoroughly"
    log_info "2. Update changelog"
    log_info "3. Build and test all target platforms"
}

# Finish a release branch
finish_release() {
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    if [[ ! "$current_branch" =~ ^${RELEASE_PREFIX} ]]; then
        log_error "Not on a release branch. Current branch: $current_branch"
        exit 1
    fi
    
    unity_preflight_check
    
    local version=${current_branch#$RELEASE_PREFIX}
    
    log_info "Finishing release: $version"
    
    # Merge into main
    git checkout $MAIN_BRANCH
    git pull origin $MAIN_BRANCH
    git merge --no-ff $current_branch -m "Release version $version"
    
    # Tag the release
    git tag -a "v$version" -m "Release version $version"
    
    # Merge into develop
    git checkout $DEVELOP_BRANCH
    git pull origin $DEVELOP_BRANCH
    git merge --no-ff $current_branch -m "Merge release $version back into develop"
    
    # Push everything
    git push origin $MAIN_BRANCH
    git push origin $DEVELOP_BRANCH
    git push origin "v$version"
    
    # Clean up release branch
    git branch -d $current_branch
    git push origin --delete $current_branch
    
    log_info "Release '$version' finished successfully!"
}

# Create hotfix branch
start_hotfix() {
    local version=$1
    
    if [ -z "$version" ]; then
        log_error "Hotfix version is required."
        echo "Usage: $0 start-hotfix <version>"
        exit 1
    fi
    
    unity_preflight_check
    
    local branch_name="${HOTFIX_PREFIX}${version}"
    
    log_info "Starting hotfix: $version"
    
    git checkout $MAIN_BRANCH
    git pull origin $MAIN_BRANCH
    git checkout -b $branch_name
    
    log_info "Hotfix branch '$branch_name' created successfully!"
    log_info "Apply your critical fixes and test thoroughly."
}

# Sync with develop branch
sync_develop() {
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    if [[ ! "$current_branch" =~ ^${FEATURE_PREFIX} ]]; then
        log_warn "Not on a feature branch. Current branch: $current_branch"
        log_warn "This operation is typically used for feature branches."
    fi
    
    unity_preflight_check
    
    log_info "Syncing current branch with $DEVELOP_BRANCH"
    
    # Fetch latest changes
    git fetch origin
    
    # Rebase current branch on develop
    git rebase origin/$DEVELOP_BRANCH
    
    # Handle potential LFS conflicts
    if git lfs status | grep -q "Objects to be committed"; then
        log_info "Resolving LFS objects..."
        git lfs pull
    fi
    
    log_info "Branch synced successfully!"
    log_info "If there were conflicts, please resolve them and continue with 'git rebase --continue'"
}

# Build and test automation
build_and_test() {
    local platform=${1:-"StandaloneWindows64"}
    
    log_info "Building Unity project for platform: $platform"
    
    # Check if Unity command line tools are available
    if ! command -v unity >/dev/null 2>&1; then
        if [ -d "/Applications/Unity/Hub/Editor" ]; then
            # macOS Unity Hub path
            UNITY_PATH=$(find /Applications/Unity/Hub/Editor -name Unity -type f | head -1)
        elif [ -d "/opt/Unity/Editor" ]; then
            # Linux Unity path
            UNITY_PATH="/opt/Unity/Editor/Unity"
        else
            log_error "Unity Editor not found. Please ensure Unity is installed."
            exit 1
        fi
    else
        UNITY_PATH="unity"
    fi
    
    # Create build directory
    BUILD_DIR="Builds/${platform}_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$BUILD_DIR"
    
    log_info "Building to: $BUILD_DIR"
    
    # Execute Unity build
    $UNITY_PATH \
        -projectPath "$(pwd)" \
        -buildTarget "$platform" \
        -buildPath "$BUILD_DIR" \
        -batchmode \
        -quit \
        -logFile "Logs/build_$(date +%Y%m%d_%H%M%S).log"
    
    if [ $? -eq 0 ]; then
        log_info "Build completed successfully!"
        log_info "Build location: $BUILD_DIR"
    else
        log_error "Build failed. Check the log file for details."
        exit 1
    fi
}

# Main script logic
case "${1:-}" in
    "start-feature")
        start_feature "$2"
        ;;
    "finish-feature")
        finish_feature
        ;;
    "start-release")
        start_release "$2"
        ;;
    "finish-release")
        finish_release
        ;;
    "start-hotfix")
        start_hotfix "$2"
        ;;
    "sync-develop")
        sync_develop
        ;;
    "build")
        build_and_test "$2"
        ;;
    *)
        echo "Unity GitFlow Helper"
        echo ""
        echo "Usage: $0 <command> [arguments]"
        echo ""
        echo "Commands:"
        echo "  start-feature <name>     Start a new feature branch"
        echo "  finish-feature           Finish current feature branch"
        echo "  start-release <version>  Start a new release branch"
        echo "  finish-release           Finish current release branch"
        echo "  start-hotfix <version>   Start a new hotfix branch"
        echo "  sync-develop             Sync current branch with develop"
        echo "  build [platform]         Build Unity project"
        echo ""
        echo "Examples:"
        echo "  $0 start-feature player-movement"
        echo "  $0 start-release 1.2.0"
        echo "  $0 build StandaloneWindows64"
        ;;
esac
```

### Unity Merge Conflict Resolution

```bash
#!/bin/bash
# Unity merge conflict resolver
# Handles common Unity file conflicts automatically

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

resolve_unity_conflicts() {
    log_info "Scanning for Unity-specific merge conflicts..."
    
    # Get list of conflicted files
    conflicted_files=$(git diff --name-only --diff-filter=U)
    
    if [ -z "$conflicted_files" ]; then
        log_info "No merge conflicts found."
        return 0
    fi
    
    echo "Conflicted files:"
    echo "$conflicted_files"
    echo ""
    
    # Process each conflicted file
    for file in $conflicted_files; do
        log_info "Processing conflict in: $file"
        
        case "$file" in
            *.unity)
                resolve_scene_conflict "$file"
                ;;
            *.prefab)
                resolve_prefab_conflict "$file"
                ;;
            *.meta)
                resolve_meta_conflict "$file"
                ;;
            *.asset)
                resolve_asset_conflict "$file"
                ;;
            ProjectSettings/*)
                resolve_project_settings_conflict "$file"
                ;;
            Packages/manifest.json)
                resolve_package_manifest_conflict "$file"
                ;;
            *)
                log_warn "Manual resolution required for: $file"
                ;;
        esac
    done
    
    log_info "Conflict resolution completed. Please review changes before committing."
}

resolve_scene_conflict() {
    local file=$1
    log_info "Resolving scene conflict: $file"
    
    # Check if Unity Smart Merge tool is available
    if command -v UnityYAMLMerge >/dev/null 2>&1; then
        log_info "Using Unity Smart Merge tool..."
        
        # Create backup
        cp "$file" "$file.backup"
        
        # Use Unity's merge tool
        UnityYAMLMerge merge -p "$file" "$file" "$file" "$file"
        
        if [ $? -eq 0 ]; then
            log_info "Unity Smart Merge resolved conflict automatically"
            git add "$file"
        else
            log_warn "Unity Smart Merge failed. Manual resolution required."
            # Restore backup if merge failed
            mv "$file.backup" "$file"
        fi
    else
        log_warn "Unity Smart Merge tool not found. Manual resolution required."
        log_info "Consider installing Unity Smart Merge or resolving manually in Unity Editor."
    fi
}

resolve_prefab_conflict() {
    local file=$1
    log_info "Resolving prefab conflict: $file"
    
    # Similar to scene resolution
    resolve_scene_conflict "$file"
}

resolve_meta_conflict() {
    local file=$1
    log_info "Resolving .meta file conflict: $file"
    
    # Check if the corresponding asset exists
    asset_file="${file%.meta}"
    
    if [ ! -f "$asset_file" ]; then
        log_warn "Asset file $asset_file not found. Removing orphaned .meta file."
        rm "$file"
        return 0
    fi
    
    # For .meta files, often we can regenerate them
    log_info "Removing conflicted .meta file to allow Unity to regenerate it"
    rm "$file"
    
    log_warn "Please open Unity Editor to regenerate the .meta file for: $asset_file"
}

resolve_asset_conflict() {
    local file=$1
    log_info "Resolving asset conflict: $file"
    
    # Use Unity's merge tool if available
    resolve_scene_conflict "$file"
}

resolve_project_settings_conflict() {
    local file=$1
    log_info "Resolving project settings conflict: $file"
    
    case "$file" in
        "ProjectSettings/ProjectVersion.txt")
            # Usually safe to take the newer Unity version
            log_info "Taking newer Unity version for ProjectVersion.txt"
            git show :3:"$file" > "$file"
            git add "$file"
            ;;
        "ProjectSettings/ProjectSettings.asset")
            log_warn "ProjectSettings.asset conflict requires manual resolution"
            log_info "Consider using Unity Editor to resolve this conflict"
            ;;
        *)
            log_warn "Manual resolution required for project settings: $file"
            ;;
    esac
}

resolve_package_manifest_conflict() {
    local file="Packages/manifest.json"
    log_info "Resolving package manifest conflict"
    
    # Extract package dependencies from both versions
    our_packages=$(git show HEAD:"$file" | jq -r '.dependencies | keys[]' 2>/dev/null || echo "")
    their_packages=$(git show MERGE_HEAD:"$file" | jq -r '.dependencies | keys[]' 2>/dev/null || echo "")
    
    if [ -z "$our_packages" ] || [ -z "$their_packages" ]; then
        log_warn "Could not parse package manifest. Manual resolution required."
        return 1
    fi
    
    log_info "Merging package dependencies..."
    
    # Create a merged manifest (simplified approach)
    # In practice, you might want more sophisticated merging logic
    git show HEAD:"$file" > "${file}.ours"
    git show MERGE_HEAD:"$file" > "${file}.theirs"
    
    log_warn "Package manifest conflict requires manual resolution."
    log_info "Files saved as ${file}.ours and ${file}.theirs for comparison."
    log_info "Please merge dependencies manually and remove temporary files."
}

# Interactive conflict resolution
interactive_resolve() {
    while true; do
        conflicted_files=$(git diff --name-only --diff-filter=U)
        
        if [ -z "$conflicted_files" ]; then
            log_info "All conflicts resolved!"
            break
        fi
        
        echo ""
        echo "Remaining conflicts:"
        echo "$conflicted_files" | nl -w2 -s'. '
        echo ""
        echo "Options:"
        echo "1. Auto-resolve Unity files"
        echo "2. Open Unity Editor (recommended for complex conflicts)"
        echo "3. Manual resolution"
        echo "4. Abort merge"
        echo ""
        
        read -p "Choose an option (1-4): " choice
        
        case $choice in
            1)
                resolve_unity_conflicts
                ;;
            2)
                log_info "Opening Unity Editor..."
                log_info "Please resolve conflicts in Unity Editor, then return here."
                
                # Try to open Unity
                if [ -d "/Applications/Unity" ]; then
                    open -a Unity
                elif command -v unity >/dev/null 2>&1; then
                    unity -projectPath "$(pwd)" &
                fi
                
                read -p "Press Enter after resolving conflicts in Unity..."
                ;;
            3)
                log_info "Please resolve conflicts manually using your preferred editor."
                log_info "After resolving, use 'git add <file>' to mark as resolved."
                read -p "Press Enter when done..."
                ;;
            4)
                log_info "Aborting merge..."
                git merge --abort
                exit 0
                ;;
            *)
                log_error "Invalid option. Please choose 1-4."
                ;;
        esac
    done
    
    log_info "All conflicts resolved! Ready to commit."
}

# Main script execution
if [ $# -eq 0 ]; then
    interactive_resolve
else
    case "$1" in
        "auto")
            resolve_unity_conflicts
            ;;
        "interactive")
            interactive_resolve
            ;;
        *)
            echo "Unity Merge Conflict Resolver"
            echo ""
            echo "Usage: $0 [auto|interactive]"
            echo ""
            echo "  auto         - Automatically resolve Unity-specific conflicts"
            echo "  interactive  - Interactive resolution mode (default)"
            ;;
    esac
fi
```

## ðŸš€ AI/LLM Integration Opportunities

### Automated Git Workflow Generation

```
Create intelligent Git workflows for Unity teams:
1. AI-powered conflict resolution strategies based on file types
2. Automated commit message generation from Unity project changes
3. Smart branching strategies based on team size and project complexity
4. Predictive merge conflict detection and prevention

Context: Unity team of 5-15 developers, multiple platforms
Focus: Workflow efficiency, conflict reduction, automated quality checks
Requirements: Unity 2022.3 LTS compatibility, cross-platform development
```

### Version Control Analytics

```
Generate Git analytics and optimization tools:
1. Repository health monitoring and metrics
2. Team productivity analysis from commit patterns
3. Asset usage tracking through Git history
4. Automated code review assignment based on expertise

Environment: Professional Unity development, continuous integration
Goals: Team efficiency, code quality, project insights
```

This comprehensive Git workflow system provides Unity teams with robust version control practices, automated conflict resolution, and team collaboration tools optimized for game development projects.